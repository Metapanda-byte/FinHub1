"use client";

import { useState, useEffect, useRef } from "react";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Download, AlertTriangle } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { useSearchStore } from "@/lib/store/search-store";
import { useIncomeStatements, useBalanceSheets, useCashFlows } from "@/lib/api/financial";
import { formatFinancialNumber, getGrowthIndicator } from "@/lib/utils/formatters";
import { cn } from "@/lib/utils";
import { Badge } from "@/components/ui/badge";
import { useToast } from "@/hooks/use-toast";
import * as XLSX from 'xlsx';
import { TableLoadingSkeleton } from "@/components/ui/loading-skeleton";

const expenseMetrics = new Set([
  "Cost of Revenue",
  "Operating Expenses",
  "Capital Expenditure",
  "Dividends Paid",
  "Total Liabilities"
]);

const formatMetric = (value: number | null | undefined, label?: string, isHeaderRow?: boolean) => {
  if (isHeaderRow) {
    return '';
  }
  if (value === null || value === undefined || isNaN(value)) {
    return '-';
  }
  const isEPS = label?.includes('EPS');
  const isPercentage = label?.includes('Growth') || label?.includes('Margin');
  
  if (isPercentage) {
    return formatPercent(value);
  }
  
  return formatFinancialNumber(value, {
    decimals: isEPS ? 2 : 0,
    useParentheses: true,
    showZeroDecimals: isEPS
  });
};

const formatPercent = (value: number) => {
  const formattedValue = Math.abs(value).toFixed(1);
  return value < 0 ? `(${formattedValue}%)` : `${formattedValue}%`;
};

const formatRatio = (value: number) => {
  return formatFinancialNumber(value, {
    decimals: 0,
    useParentheses: true,
    showZeroDecimals: false,
  });
};

const calculateCAGR = (startValue: number, endValue: number, years: number) => {
  if (startValue === 0 || years === 0) return 0;
  return (Math.pow(endValue / startValue, 1 / years) - 1) * 100;
};

// Helper to build periods grouped by year for quarterly data
function getPeriodsByYear(statements: any[]) {
  const periodsByYear: Record<string, string[]> = {};
  statements.forEach(s => {
    if (!s.period) return;
    
    // Use calendarYear if available (for API format like period: "Q3", calendarYear: "2025")
    let year: string;
    if (s.calendarYear) {
      year = s.calendarYear;
    } else {
      // Fallback: Extract 4-digit year from the period string using regex
      const match = s.period.match(/(\d{4})/);
      if (!match) {
        console.warn('[getPeriodsByYear] Could not extract year from period:', s.period, 'and no calendarYear provided');
        return;
      }
      year = match[1];
    }
    
    if (!periodsByYear[year]) periodsByYear[year] = [];
    if (!periodsByYear[year].includes(s.period)) periodsByYear[year].push(s.period);
  });
  
  // Ensure Q1-Q4 order for each year - handle both formats
  Object.keys(periodsByYear).forEach(year => {
    periodsByYear[year] = ['Q1','Q2','Q3','Q4']
      .map(q => {
        // Find the period string that matches this quarter
        // Handle both "Q3" format and "2025-Q3" format
        return periodsByYear[year].find(p => 
          p === q || // Direct match like "Q3"
          (p.includes(year) && p.includes(q)) // Full format like "2025-Q3"
        );
      })
      .filter(Boolean) as string[];
  });
  return periodsByYear;
}

// Helper to get LTM reference date in MMM-YY format from quarterly data
function getLTMReferenceDate(quarterlyMap: Record<string, any>): string {
  if (!quarterlyMap || Object.keys(quarterlyMap).length === 0) return 'LTM';
  
  // Get all periods and sort them to find the most recent
  const periods = Object.keys(quarterlyMap).sort();
  if (periods.length === 0) return 'LTM';
  
  const mostRecentPeriod = periods[periods.length - 1];
  const match = mostRecentPeriod.match(/(\d{4})-Q([1-4])/);
  if (!match) return 'LTM';
  
  const year = match[1];
  const quarter = match[2];
  
  // Convert quarter to month (Q4=Dec, Q3=Sep, Q2=Jun, Q1=Mar)
  const monthMap = { '1': 'Mar', '2': 'Jun', '3': 'Sep', '4': 'Dec' };
  const month = monthMap[quarter as keyof typeof monthMap];
  const yearShort = year.slice(-2); // Get last 2 digits of year
  return `${month}-${yearShort}`;
}

// Helper to calculate LTM (Last Twelve Months) value from quarterly periodMap
function calculateLTMFromQuarterly(quarterlyMap: Record<string, any>, field: string): number | null {
  if (!quarterlyMap || Object.keys(quarterlyMap).length === 0) return null;
  
  // Get all periods and sort them
  const periods = Object.keys(quarterlyMap).sort();
  if (periods.length < 4) return null; // Need at least 4 quarters
  
  // Get the 4 most recent quarters
  const recentPeriods = periods.slice(-4);
  
  let values: number[] = [];
  for (const period of recentPeriods) {
    const value = quarterlyMap[period]?.[field];
    if (value !== null && value !== undefined && !isNaN(value)) {
      values.push(value);
    }
  }
  
  // Need exactly 4 quarters for LTM calculation
  if (values.length !== 4) return null;
  
  // Sum the 4 quarters
  return values.reduce((sum, val) => sum + val, 0);
}

// Helper to normalize period keys
function normalizePeriod(period: string, type: 'annual' | 'quarter', calendarYear?: string, date?: string): string | null {
  if (!period && !date) return null;
  
  if (type === 'annual') {
    // For annual data, use calendarYear if available, otherwise try to extract from period
    if (calendarYear) {
      return calendarYear;
    }
    const yearMatch = period?.match(/(\d{4})/);
    if (!yearMatch) return null;
    return yearMatch[1];
  } else {
    // For quarterly data, we need to determine the quarter from the date
    // API might provide date like "2024-03-31" for Q1, "2024-06-30" for Q2, etc.
    if (date) {
      const dateObj = new Date(date);
      const year = dateObj.getFullYear();
      const month = dateObj.getMonth() + 1; // getMonth() is 0-indexed
      
      let quarter: string;
      if (month <= 3) quarter = 'Q1';
      else if (month <= 6) quarter = 'Q2';
      else if (month <= 9) quarter = 'Q3';
      else quarter = 'Q4';
      
      const result = `${year}-${quarter}`;
      return result;
    }
    
    // Handle direct Q1, Q2, Q3, Q4 format from API (no year in period string)
    if (period && period.match(/^Q[1-4]$/i)) {
      // Direct format like "Q3" - use with calendar year
      if (!calendarYear) {
        return null;
      }
      const result = `${calendarYear}-${period.toUpperCase()}`;
      return result;
    }
    
    // Fallback: try to extract year from period string for other formats
    const yearMatch = period?.match(/(\d{4})/);
    if (!yearMatch) {
      return null;
    }
    const year = yearMatch[1];
    
    const quarterMatch = period.match(/Q([1-4])/i) || 
                       period.match(/([1-4])Q/i) ||
                       period.match(/Quarter\s*([1-4])/i);
    if (!quarterMatch) {
      return null;
    }
    const result = `${year}-Q${quarterMatch[1]}`;
    return result;
  }
}

export function HistoricalFinancials() {
  const [activeFinancialTab, setActiveFinancialTab] = useState('income-statement');
  const [selectedPeriod, setSelectedPeriod] = useState<'annual' | 'quarter'>('annual');
  const [showSubscriptionWarning, setShowSubscriptionWarning] = useState(false);
  const [isExporting, setIsExporting] = useState(false);
  const currentSymbol = useSearchStore((state) => state.currentSymbol);
  const { toast } = useToast();
  const tableContainerRefs = useRef<{ [key: string]: HTMLDivElement | null }>({});

  const { statements: incomeStatements, isLoading: incomeLoading } = useIncomeStatements(currentSymbol || '', selectedPeriod);
  const { statements: cashFlowStatements, isLoading: cashFlowLoading } = useCashFlows(currentSymbol || '', selectedPeriod);
  const { statements: balanceSheets, isLoading: balanceSheetLoading } = useBalanceSheets(currentSymbol || '', selectedPeriod);
  
  // Always fetch quarterly data for LTM calculations
  const { statements: incomeStatementsQuarterly } = useIncomeStatements(currentSymbol || '', 'quarter');
  const { statements: cashFlowStatementsQuarterly } = useCashFlows(currentSymbol || '', 'quarter');
  const { statements: balanceSheetsQuarterly } = useBalanceSheets(currentSymbol || '', 'quarter');



  // Check if quarterly data is actually annual data (indicating fallback)
  useEffect(() => {
    if (selectedPeriod === 'quarter' && incomeStatements && incomeStatements.length > 0) {
      const firstStatement = incomeStatements[0];
      // Check if the period is actually annual (FY) instead of quarterly
      if (firstStatement.period === 'FY' || firstStatement.period?.includes('FY')) {
        setShowSubscriptionWarning(true);
      } else {
        setShowSubscriptionWarning(false);
      }
    } else {
      setShowSubscriptionWarning(false);
    }
  }, [selectedPeriod, incomeStatements]);

  // Auto-scroll to rightmost position when data loads
  useEffect(() => {
    if (!incomeLoading && !cashFlowLoading && !balanceSheetLoading) {
      const scrollToEnd = (container: HTMLDivElement) => {
        container.scrollLeft = container.scrollWidth - container.clientWidth;
      };
      
      // Scroll all table containers to the end
      Object.values(tableContainerRefs.current).forEach(container => {
        if (container) {
          setTimeout(() => scrollToEnd(container), 100);
        }
      });
    }
  }, [incomeLoading, cashFlowLoading, balanceSheetLoading, selectedPeriod, activeFinancialTab, currentSymbol]);

  // Debug: Log the structure of the first two income statements
  if (incomeStatements && incomeStatements.length > 0) {
  }

  if (!currentSymbol || incomeLoading || cashFlowLoading || balanceSheetLoading) {
    return (
      <div className="space-y-4">
        <Card>
          <CardHeader className="pb-3">
            <CardTitle className="text-xl font-bold">Loading...</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="h-[200px] flex items-center justify-center">
              <div className="animate-pulse space-y-4">
                <div className="h-4 w-48 bg-muted rounded"></div>
                <div className="h-4 w-36 bg-muted rounded"></div>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  if (!incomeStatements || !cashFlowStatements || !balanceSheets) {
    return (
      <div className="space-y-4">
        <Card>
          <CardHeader>
            <CardTitle className="text-xl font-bold">No Data Available</CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-muted-foreground">Unable to fetch financial statements.</p>
          </CardContent>
        </Card>
      </div>
    );
  }

  // Build periods for table columns
  let years: string[] = [];
  let periodsByYear: Record<string, string[]> = {};
  if (selectedPeriod === 'quarter') {
    periodsByYear = getPeriodsByYear(incomeStatements);
    // Only include years that have at least one valid quarter, limit to 5 most recent fiscal years
    years = Object.keys(periodsByYear)
      .filter(year => /\d{4}/.test(year) && periodsByYear[year].length > 0)
      .sort((a, b) => Number(a) - Number(b))
      .slice(-5);
  } else {
    years = Array.from(new Set(incomeStatements.map(s => s.calendarYear)))
      .filter(y => y)
      .sort((a, b) => Number(a) - Number(b))
      .slice(-10);
  }

  // Create periodMaps for LTM date calculation
  const incomePeriodMap: Record<string, any> = {};
  incomeStatements.forEach(s => {
    const norm = normalizePeriod(s.period, selectedPeriod, s.calendarYear, s.date);
    if (norm) incomePeriodMap[norm] = s;
  });

  const cashFlowPeriodMap: Record<string, any> = {};
  cashFlowStatements.forEach(s => {
    const norm = normalizePeriod(s.period, selectedPeriod, s.calendarYear, s.date);
    if (norm) cashFlowPeriodMap[norm] = s;
  });

  const balancePeriodMap: Record<string, any> = {};
  balanceSheets.forEach(s => {
    const norm = normalizePeriod(s.period, selectedPeriod, s.calendarYear, s.date);
    if (norm) balancePeriodMap[norm] = s;
  });
  
  // Create quarterly period maps for LTM calculations
  const incomeQuarterlyMap: Record<string, any> = {};
  if (incomeStatementsQuarterly) {
    incomeStatementsQuarterly.forEach(s => {
      const norm = normalizePeriod(s.period, 'quarter', s.calendarYear, s.date);
      if (norm) incomeQuarterlyMap[norm] = s;
    });
  }
  
  const cashFlowQuarterlyMap: Record<string, any> = {};
  if (cashFlowStatementsQuarterly) {
    cashFlowStatementsQuarterly.forEach(s => {
      const norm = normalizePeriod(s.period, 'quarter', s.calendarYear, s.date);
      if (norm) cashFlowQuarterlyMap[norm] = s;
    });
  }
  
  const balanceQuarterlyMap: Record<string, any> = {};
  if (balanceSheetsQuarterly) {
    balanceSheetsQuarterly.forEach(s => {
      const norm = normalizePeriod(s.period, 'quarter', s.calendarYear, s.date);
      if (norm) balanceQuarterlyMap[norm] = s;
    });
  }

  // Updated table rendering for quarters
    const renderFinancialTable = (data: any[], title: string, periodMap?: Record<string, any>, quarterlyMap?: Record<string, any>) => {
    return (
      <div 
        ref={(el) => { tableContainerRefs.current[title] = el; }}
        className="overflow-x-auto rounded-lg border-2 border-slate-200 dark:border-slate-700 shadow-sm"
      >
        <table className="w-full border-collapse">
          <thead className="sticky top-0 bg-slate-50 dark:bg-slate-900/90 backdrop-blur">
            <tr className="border-b border-slate-800 dark:border-slate-200">
              <th className={cn(
                "text-left py-3 px-6 font-bold text-sm text-slate-800 dark:text-slate-200 align-bottom",
                "min-w-80 sticky left-0 z-30 bg-slate-50 dark:bg-slate-900/90"
              )}>
                {title}
              </th>
              {selectedPeriod === 'quarter'
                ? years.map(year => (
                    <th key={year} colSpan={4} className="text-center py-3 px-6 font-bold text-sm text-slate-800 dark:text-slate-200 align-bottom">FY{year.slice(-2)}</th>
                  ))
                : [...years.map(year => (
                    <th key={year} className="text-right py-3 px-4 font-bold text-sm text-slate-800 dark:text-slate-200 align-bottom" style={{ minWidth: '100px' }}>{`FY ${year}`}</th>
                  )), 
                  <th key="ltm" className="text-center py-3 px-4 font-bold text-sm text-slate-800 dark:text-slate-200 align-bottom" style={{ minWidth: '100px' }}>LTM</th>]}
            </tr>
            {selectedPeriod === 'quarter' && (
              <tr className="border-none !bg-transparent" style={{ backgroundColor: 'transparent !important' }}>
                <th className="text-left py-1.5 px-6 text-xs font-medium text-slate-600 dark:text-slate-400 align-bottom border-none !bg-transparent min-w-80 sticky left-0 z-30 bg-slate-50 dark:bg-slate-900/90" style={{ backgroundColor: 'transparent !important' }}>In $m unless otherwise specified</th>
                {years.map(year => ["Q1","Q2","Q3","Q4"].map(q => (
                  <th key={year+q} className="text-right py-1.5 px-4 text-xs font-semibold text-slate-700 dark:text-slate-300 align-bottom border-none !bg-transparent" style={{ backgroundColor: 'transparent !important', minWidth: '80px' }}>{q}</th>
                ))).flat()}
              </tr>
            )}
            {selectedPeriod === 'annual' && (
              <tr className="border-none !bg-transparent" style={{ backgroundColor: 'transparent !important' }}>
                <th className="text-left py-1.5 px-6 text-xs font-medium text-slate-600 dark:text-slate-400 align-bottom border-none !bg-transparent min-w-80 sticky left-0 z-30 bg-slate-50 dark:bg-slate-900/90" style={{ backgroundColor: 'transparent !important' }}>In $m unless otherwise specified</th>
                {years.map(year => (
                  <th key={year} className="text-right py-1.5 px-4 text-xs font-medium text-slate-600 dark:text-slate-400 align-bottom border-none !bg-transparent" style={{ backgroundColor: 'transparent !important', minWidth: '100px' }}></th>
                ))}
                <th key="ltm-sub" className="text-right py-1.5 px-4 text-xs font-semibold text-slate-700 dark:text-slate-300 align-bottom border-none !bg-transparent" style={{ backgroundColor: 'transparent !important', minWidth: '100px' }}>
                  {quarterlyMap ? getLTMReferenceDate(quarterlyMap) : 'LTM'}
                </th>
              </tr>
            )}
          </thead>
          <tbody className="bg-white dark:bg-slate-950">
            {data.map((row, index) => {
              const isExpense = expenseMetrics.has(row.label);
              const hasBorder = row.hasBorder;
              const isEBITDA = row.isEBITDA;
              const nextRow = data[index + 1];
              const isLastBorderRow = hasBorder && (!nextRow || !nextRow.hasBorder);
              return (
                <tr 
                  key={row.label} 
                  className={cn(
                    "group transition-colors relative",
                    row.isImportant && !row.isEBITDA ? "before:absolute before:inset-y-0 before:left-6 before:right-6 before:bg-slate-50 dark:before:bg-slate-900/50 before:-z-10" : "",
                    row.isEBITDA ? "before:absolute before:inset-y-0 before:left-6 before:right-6 before:bg-blue-50/80 dark:before:bg-blue-950/30 before:-z-10" : "",
                    row.hasBorderTop ? "after:absolute after:top-0 after:left-6 after:right-6 after:h-px after:bg-slate-800 dark:after:bg-slate-200" : "",
                    row.isMargin ? "text-slate-500 dark:text-slate-400" : "",
                    "hover:bg-slate-25 dark:hover:bg-slate-900/25"
                  )}
                >
                  <td className={cn(
                    "py-1.5 text-sm flex items-center gap-2 relative z-10",
                    row.isIndented ? "px-8" : "px-6",
                    row.isImportant ? "font-semibold" : "",
                    row.isBold ? "font-bold" : "",
                    row.isMargin ? "text-slate-500 dark:text-slate-400" : "",
                    "min-w-80 sticky left-0 z-20 bg-white dark:bg-slate-950"
                  )}>
                    {row.label}
                  </td>
                  {selectedPeriod === 'quarter'
                    ? years.flatMap(year => ["Q1","Q2","Q3","Q4"].map(q => {
                        const period = `${year}-${q}`;
                        return (
                          <td key={period} className={cn(
                            "text-right py-1.5 px-4 text-sm tabular-nums relative z-10",
                            row.isImportant ? "font-semibold" : "",
                            row.isMargin ? "text-slate-500 dark:text-slate-400" : ""
                          )} style={{ minWidth: '80px' }}>
                            {formatMetric(row[period], row.label, row.isHeaderRow)}
                          </td>
                        );
                      }))
                    : [...years.map(year => (
                        <td key={year} className={cn(
                          "text-right py-1.5 px-4 text-sm tabular-nums relative z-10",
                          row.isImportant ? "font-semibold" : "",
                          row.isMargin ? "text-slate-500 dark:text-slate-400" : ""
                        )} style={{ minWidth: '100px' }}>
                          {formatMetric(row[year], row.label, row.isHeaderRow)}
                        </td>
                      )),
                      <td key="ltm" className={cn(
                        "text-right py-1.5 px-4 text-sm tabular-nums font-medium bg-muted/20 relative z-10",
                        row.isImportant ? "font-semibold" : "",
                        row.isMargin ? "text-slate-500 dark:text-slate-400" : ""
                      )} style={{ minWidth: '100px' }}>
                        {formatMetric(row.ltm, row.label, row.isHeaderRow)}
                      </td>]}
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>
    );
  };

  const processIncomeStatements = (quarterlyMap?: Record<string, any>) => {
    const type = selectedPeriod;
    
    // Build a map of normalized period -> statement
    const periodMap: Record<string, any> = {};
    incomeStatements.forEach(s => {
      const norm = normalizePeriod(s.period, type, s.calendarYear, s.date);
      if (norm) periodMap[norm] = s;
    });
    
    // For annual, use years; for quarter, use all year-Qx in periodsByYear
    const periods = type === 'annual'
      ? years
      : years.flatMap(year => ['Q1','Q2','Q3','Q4'].map(q => `${year}-${q}`));
    const data = [
      {
        label: "Revenue",
        isImportant: true,
        isBold: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.revenue ?? null])),
        ltm: quarterlyMap ? calculateLTMFromQuarterly(quarterlyMap, 'revenue') : null,
        unit: 'millions'
      },
      {
        label: "(-) COGS",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.costOfRevenue ? -periodMap[p].costOfRevenue : null])),
        ltm: quarterlyMap ? (() => {
          const ltmValue = calculateLTMFromQuarterly(quarterlyMap, 'costOfRevenue');
          return ltmValue ? -ltmValue : null;
        })() : null,
        unit: 'millions'
      },
      {
        label: "Gross Profit",
        isImportant: true,
        hasBorderTop: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.grossProfit ?? null])),
        ltm: quarterlyMap ? calculateLTMFromQuarterly(quarterlyMap, 'grossProfit') : null,
        unit: 'millions'
      },
      {
        label: "% Margin",
        isMargin: true,
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.grossProfit && periodMap[p]?.revenue ? (periodMap[p].grossProfit / periodMap[p].revenue) * 100 : null])),
        ltm: quarterlyMap ? (() => {
          const ltmGross = calculateLTMFromQuarterly(quarterlyMap, 'grossProfit');
          const ltmRevenue = calculateLTMFromQuarterly(quarterlyMap, 'revenue');
          return ltmGross && ltmRevenue ? (ltmGross / ltmRevenue) * 100 : null;
        })() : null,
        unit: 'millions'
      },
      {
        label: "(-) R&D",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.researchAndDevelopmentExpenses ? -periodMap[p].researchAndDevelopmentExpenses : null])),
        ltm: quarterlyMap ? (() => {
          const ltmValue = calculateLTMFromQuarterly(quarterlyMap, 'researchAndDevelopmentExpenses');
          return ltmValue ? -ltmValue : null;
        })() : null,
        unit: 'millions'
      },
      {
        label: "(-) SG&A",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, (() => {
          // Intelligently use the best available SG&A data
          const separateSales = periodMap[p]?.salesAndMarketingExpenses || 0;
          const separateGA = periodMap[p]?.generalAndAdministrativeExpenses || 0;
          const combinedSGA = periodMap[p]?.sellingGeneralAndAdministrativeExpenses || 0;
          
          // If we have individual components with actual values, sum them
          if (separateSales > 0 || separateGA > 0) {
            const total = separateSales + separateGA;
            return total > 0 ? -total : null;
          }
          
          // Otherwise use the combined SG&A field
          return combinedSGA > 0 ? -combinedSGA : null;
        })()])),
        ltm: quarterlyMap ? (() => {
          const salesLTM = calculateLTMFromQuarterly(quarterlyMap, 'salesAndMarketingExpenses') || 0;
          const gaLTM = calculateLTMFromQuarterly(quarterlyMap, 'generalAndAdministrativeExpenses') || 0;
          const combinedLTM = calculateLTMFromQuarterly(quarterlyMap, 'sellingGeneralAndAdministrativeExpenses') || 0;
          
          if (salesLTM > 0 || gaLTM > 0) {
            const total = salesLTM + gaLTM;
            return total > 0 ? -total : null;
          }
          
          return combinedLTM > 0 ? -combinedLTM : null;
        })() : null,
        unit: 'millions'
      },
      {
        label: "(-) Other Op Expenses",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.otherExpenses ? -periodMap[p].otherExpenses : null])),
        ltm: quarterlyMap ? (() => {
          const ltmValue = calculateLTMFromQuarterly(quarterlyMap, 'otherExpenses');
          return ltmValue ? -ltmValue : null;
        })() : null,
        unit: 'millions'
      },
      {
        label: "(-) Total Op Expenses",
        isIndented: true,
        isBold: true,
        isImportant: true,
        ...Object.fromEntries(periods.map(p => [p, (() => {
          const rd = periodMap[p]?.researchAndDevelopmentExpenses || 0;
          const separateSales = periodMap[p]?.salesAndMarketingExpenses || 0;
          const separateGA = periodMap[p]?.generalAndAdministrativeExpenses || 0;
          const combinedSGA = periodMap[p]?.sellingGeneralAndAdministrativeExpenses || 0;
          const other = periodMap[p]?.otherExpenses || 0;
          
          // Use the same logic as the SG&A line above
          const sgaTotal = (separateSales > 0 || separateGA > 0) ? (separateSales + separateGA) : combinedSGA;
          const total = rd + sgaTotal + other;
          
          return total > 0 ? -total : null;
        })()])),
        ltm: quarterlyMap ? (() => {
          const rdLTM = calculateLTMFromQuarterly(quarterlyMap, 'researchAndDevelopmentExpenses') || 0;
          const salesLTM = calculateLTMFromQuarterly(quarterlyMap, 'salesAndMarketingExpenses') || 0;
          const gaLTM = calculateLTMFromQuarterly(quarterlyMap, 'generalAndAdministrativeExpenses') || 0;
          const combinedSGALTM = calculateLTMFromQuarterly(quarterlyMap, 'sellingGeneralAndAdministrativeExpenses') || 0;
          const otherLTM = calculateLTMFromQuarterly(quarterlyMap, 'otherExpenses') || 0;
          
          const sgaTotalLTM = (salesLTM > 0 || gaLTM > 0) ? (salesLTM + gaLTM) : combinedSGALTM;
          const totalLTM = rdLTM + sgaTotalLTM + otherLTM;
          
          return totalLTM > 0 ? -totalLTM : null;
        })() : null,
        unit: 'millions'
      },
      {
        label: "(+) D&A",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.depreciationAndAmortization ?? null])),
        ltm: quarterlyMap ? calculateLTMFromQuarterly(quarterlyMap, 'depreciationAndAmortization') : null,
        unit: 'millions'
      },
      {
        label: "EBITDA",
        isImportant: true,
        isBold: true,
        isEBITDA: true,
        hasBorderTop: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.ebitda ?? null])),
        ltm: type === 'annual' ? periodMap[years[years.length - 1]]?.ebitda ?? null : calculateLTM(periodMap, 'ebitda', years),
        unit: 'millions'
      },
      {
        label: "% Margin",
        isMargin: true,
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.ebitda && periodMap[p]?.revenue ? (periodMap[p].ebitda / periodMap[p].revenue) * 100 : null])),
        ltm: type === 'annual' ? (periodMap[years[years.length - 1]]?.ebitda && periodMap[years[years.length - 1]]?.revenue ? (periodMap[years[years.length - 1]].ebitda / periodMap[years[years.length - 1]].revenue) * 100 : null) : (calculateLTM(periodMap, 'ebitda', years) && calculateLTM(periodMap, 'revenue', years) ? (calculateLTM(periodMap, 'ebitda', years)! / calculateLTM(periodMap, 'revenue', years)!) * 100 : null),
        unit: 'millions'
      },
      {
        label: "(-) D&A",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.depreciationAndAmortization ? -periodMap[p].depreciationAndAmortization : null])),
        ltm: type === 'annual' ? (periodMap[years[years.length - 1]]?.depreciationAndAmortization ? -periodMap[years[years.length - 1]].depreciationAndAmortization : null) : (() => {
          const ltmValue = calculateLTM(periodMap, 'depreciationAndAmortization', years);
          return ltmValue ? -ltmValue : null;
        })(),
        unit: 'millions'
      },
      {
        label: "Operating Income",
        isImportant: true,
        hasBorderTop: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.operatingIncome ?? null])),
        ltm: type === 'annual' ? periodMap[years[years.length - 1]]?.operatingIncome ?? null : calculateLTM(periodMap, 'operatingIncome', years),
        unit: 'millions'
      },
      {
        label: "% Margin",
        isMargin: true,
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.operatingIncome && periodMap[p]?.revenue ? (periodMap[p].operatingIncome / periodMap[p].revenue) * 100 : null])),
        ltm: type === 'annual' ? (periodMap[years[years.length - 1]]?.operatingIncome && periodMap[years[years.length - 1]]?.revenue ? (periodMap[years[years.length - 1]].operatingIncome / periodMap[years[years.length - 1]].revenue) * 100 : null) : (calculateLTM(periodMap, 'operatingIncome', years) && calculateLTM(periodMap, 'revenue', years) ? (calculateLTM(periodMap, 'operatingIncome', years)! / calculateLTM(periodMap, 'revenue', years)!) * 100 : null),
        unit: 'millions'
      },
      {
        label: "(+) Interest Income",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.interestIncome ?? null])),
        ltm: type === 'annual' ? periodMap[years[years.length - 1]]?.interestIncome ?? null : calculateLTM(periodMap, 'interestIncome', years),
        unit: 'millions'
      },
      {
        label: "(-) Interest Expense",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.interestExpense ? -periodMap[p].interestExpense : null])),
        ltm: type === 'annual' ? (periodMap[years[years.length - 1]]?.interestExpense ? -periodMap[years[years.length - 1]].interestExpense : null) : (() => {
          const ltmValue = calculateLTM(periodMap, 'interestExpense', years);
          return ltmValue ? -ltmValue : null;
        })(),
        unit: 'millions'
      },
      {
        label: "(+/-) Other Non-Op Income",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.totalOtherIncomeExpensesNet ?? null])),
        ltm: type === 'annual' ? periodMap[years[years.length - 1]]?.totalOtherIncomeExpensesNet ?? null : calculateLTM(periodMap, 'totalOtherIncomeExpensesNet', years),
        unit: 'millions'
      },
      {
        label: "(+/-) Extraordinary Items",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.extraordinaryItems ?? null])),
        ltm: type === 'annual' ? periodMap[years[years.length - 1]]?.extraordinaryItems ?? null : calculateLTM(periodMap, 'extraordinaryItems', years),
        unit: 'millions'
      },
      {
        label: "Income Before Tax",
        isImportant: true,
        hasBorderTop: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.incomeBeforeTax ?? null])),
        ltm: type === 'annual' ? periodMap[years[years.length - 1]]?.incomeBeforeTax ?? null : calculateLTM(periodMap, 'incomeBeforeTax', years),
        unit: 'millions'
      },
      {
        label: "(-) Income Tax Expense",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.incomeTaxExpense ? -periodMap[p].incomeTaxExpense : null])),
        ltm: type === 'annual' ? (periodMap[years[years.length - 1]]?.incomeTaxExpense ? -periodMap[years[years.length - 1]].incomeTaxExpense : null) : (() => {
          const ltmValue = calculateLTM(periodMap, 'incomeTaxExpense', years);
          return ltmValue ? -ltmValue : null;
        })(),
        unit: 'millions'
      },
      {
        label: "Net Income",
        isImportant: true,
        isBold: true,
        hasBorderTop: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.netIncome ?? null])),
        ltm: type === 'annual' ? periodMap[years[years.length - 1]]?.netIncome ?? null : calculateLTM(periodMap, 'netIncome', years),
        unit: 'millions'
      },
      {
        label: "% Margin",
        isMargin: true,
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.netIncome && periodMap[p]?.revenue ? (periodMap[p].netIncome / periodMap[p].revenue) * 100 : null])),
        ltm: type === 'annual' ? (periodMap[years[years.length - 1]]?.netIncome && periodMap[years[years.length - 1]]?.revenue ? (periodMap[years[years.length - 1]].netIncome / periodMap[years[years.length - 1]].revenue) * 100 : null) : (calculateLTM(periodMap, 'netIncome', years) && calculateLTM(periodMap, 'revenue', years) ? (calculateLTM(periodMap, 'netIncome', years)! / calculateLTM(periodMap, 'revenue', years)!) * 100 : null),
        unit: 'millions'
      },
      {
        label: "Diluted EPS",
        isImportant: true,
        ...Object.fromEntries(periods.map(p => [p, (() => {
          // Use epsDiluted if available, otherwise calculate from netIncome / diluted shares
          const epsDiluted = periodMap[p]?.epsDiluted;
          if (epsDiluted !== null && epsDiluted !== undefined) {
            return epsDiluted;
          }
          const netIncomeMillions = periodMap[p]?.netIncome; // Net income is in millions
          const rawShares = periodMap[p]?.weightedAverageShsOutDil || 
                           periodMap[p]?.weightedAverageShsOut || 
                           periodMap[p]?.weightedAverageSharesOutstandingDiluted ||
                           periodMap[p]?.dilutedAverageShares ||
                           null;
          if (netIncomeMillions && rawShares && rawShares !== 0) {
            // Convert to millions - most APIs provide raw share count
            const sharesInMillions = rawShares / 1000000;
            // EPS = Net Income (millions) / Shares (millions) = dollars per share
            return netIncomeMillions / sharesInMillions;
          }
          return periodMap[p]?.eps ?? null;
        })()])),
        ltm: type === 'annual' ? (() => {
          const last = periodMap[years[years.length - 1]];
          if (!last) return null;
          const epsDiluted = last.epsDiluted;
          if (epsDiluted !== null && epsDiluted !== undefined) {
            return epsDiluted;
          }
          const netIncomeMillions = last.netIncome;
          const rawShares = last.weightedAverageShsOutDil || last.weightedAverageShsOut || last.weightedAverageSharesOutstandingDiluted || last.dilutedAverageShares || null;
          if (netIncomeMillions && rawShares && rawShares !== 0) {
            const sharesInMillions = rawShares / 1000000;
            return netIncomeMillions / sharesInMillions;
          }
          return last.eps ?? null;
        })() : (() => {
          const ltmNetIncomeMillions = calculateLTM(periodMap, 'netIncome', years);
          let ltmRawShares = calculateLTM(periodMap, 'weightedAverageShsOutDil', years);
          if (!ltmRawShares) ltmRawShares = calculateLTM(periodMap, 'weightedAverageShsOut', years);
          if (!ltmRawShares) ltmRawShares = calculateLTM(periodMap, 'weightedAverageSharesOutstandingDiluted', years);
          if (!ltmRawShares) ltmRawShares = calculateLTM(periodMap, 'dilutedAverageShares', years);
          
          if (ltmNetIncomeMillions && ltmRawShares && ltmRawShares !== 0) {
            const ltmSharesInMillions = ltmRawShares / 1000000;
            return ltmNetIncomeMillions / ltmSharesInMillions;
          }
          return calculateLTM(periodMap, 'epsDiluted', years) || calculateLTM(periodMap, 'eps', years);
        })(),
        unit: 'dollars'
      }
    ];
    
    return data;
  };

  const processCashFlowStatements = () => {
    const type = selectedPeriod;
    // Build a map of normalized period -> statement
    const periodMap: Record<string, any> = {};
    cashFlowStatements.forEach(s => {
      const norm = normalizePeriod(s.period, type, s.calendarYear, s.date);
      if (norm) periodMap[norm] = s;
    });
    // For annual, use years; for quarter, use all year-Qx in periodsByYear
    const periods = type === 'annual'
      ? years
      : years.flatMap(year => ['Q1','Q2','Q3','Q4'].map(q => `${year}-${q}`));
    const data = [
      {
        label: "Net Income",
        isImportant: true,
        isBold: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.netIncome ?? null])),
        ltm: type === 'annual' ? periodMap[years[years.length - 1]]?.netIncome ?? null : calculateLTM(periodMap, 'netIncome', years),
        unit: 'millions'
      },
      {
        label: "(+) D&A",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.depreciationAndAmortization ?? null])),
        ltm: quarterlyMap ? calculateLTMFromQuarterly(quarterlyMap, 'depreciationAndAmortization') : null,
        unit: 'millions'
      },
      {
        label: "(+) Stock-Based Comp",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.stockBasedCompensation ?? null])),
        ltm: type === 'annual' ? periodMap[years[years.length - 1]]?.stockBasedCompensation ?? null : calculateLTM(periodMap, 'stockBasedCompensation', years),
        unit: 'millions'
      },
      {
        label: "(+/-) Working Capital",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.changeInWorkingCapital ?? null])),
        ltm: type === 'annual' ? periodMap[years[years.length - 1]]?.changeInWorkingCapital ?? null : calculateLTM(periodMap, 'changeInWorkingCapital', years),
        unit: 'millions'
      },
      {
        label: "(+) Other Operating Activities",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, (() => {
          const otherOperating = periodMap[p]?.otherOperatingActivities || 0;
          return otherOperating !== 0 ? otherOperating : null;
        })()])),
        unit: 'millions'
      },
      {
        label: "Operating Cash Flow",
        isImportant: true,
        isBold: true,
        hasBorderTop: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.operatingCashFlow ?? null])),
        ltm: type === 'annual' ? periodMap[years[years.length - 1]]?.operatingCashFlow ?? null : calculateLTM(periodMap, 'operatingCashFlow', years),
        unit: 'millions'
      },
      {
        label: "(-) Capital Expenditure",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.capitalExpenditure ?? null])),
        ltm: type === 'annual' ? periodMap[years[years.length - 1]]?.capitalExpenditure ?? null : calculateLTM(periodMap, 'capitalExpenditure', years),
        unit: 'millions'
      },
      {
        label: "(-) Acquisitions",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.acquisitionsNet ?? null])),
        ltm: type === 'annual' ? periodMap[years[years.length - 1]]?.acquisitionsNet ?? null : calculateLTM(periodMap, 'acquisitionsNet', years),
        unit: 'millions'
      },
      {
        label: "(+/-) Investment Activities",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, (() => {
          const purchases = periodMap[p]?.purchasesOfInvestments || 0;
          const sales = periodMap[p]?.salesMaturitiesOfInvestments || 0;
          const net = sales - purchases;
          return net !== 0 ? net : null;
        })()])),
        ltm: type === 'annual' ? (() => {
          const last = periodMap[years[years.length - 1]];
          if (!last) return null;
          const purchases = last.purchasesOfInvestments || 0;
          const sales = last.salesMaturitiesOfInvestments || 0;
          const net = sales - purchases;
          return net !== 0 ? net : null;
        })() : null,
        unit: 'millions'
      },
      {
        label: "(+/-) Other Investing Activities",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, (() => {
          const other = periodMap[p]?.otherInvestingActivites || 0;
          return other !== 0 ? other : null;
        })()])),
        unit: 'millions'
      },
      {
        label: "Investing Cash Flow",
        isImportant: true,
        hasBorderTop: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.netCashUsedForInvestingActivites ?? periodMap[p]?.investingCashFlow ?? null])),
        ltm: type === 'quarter' ? (calculateLTM(periodMap, 'netCashUsedForInvestingActivites', years) ?? calculateLTM(periodMap, 'investingCashFlow', years)) : null,
        unit: 'millions'
      },
      {
        label: "(-) Debt Repayment",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.debtRepayment ?? null])),
        unit: 'millions'
      },
      {
        label: "(+) Stock Issuance",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.commonStockIssued ?? null])),
        unit: 'millions'
      },
      {
        label: "(-) Stock Repurchase",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.commonStockRepurchased ?? null])),
        unit: 'millions'
      },
      {
        label: "(-) Dividends Paid",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.dividendsPaid ?? null])),
        unit: 'millions'
      },
      {
        label: "(+) Other Financing Activities",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, (() => {
          const otherFinancing = periodMap[p]?.otherFinancingActivites || 0;
          return otherFinancing !== 0 ? otherFinancing : null;
        })()])),
        unit: 'millions'
      },
      {
        label: "Financing Cash Flow",
        isImportant: true,
        hasBorderTop: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.netCashUsedProvidedByFinancingActivities ?? periodMap[p]?.financingCashFlow ?? null])),
        ltm: type === 'quarter' ? (calculateLTM(periodMap, 'netCashUsedProvidedByFinancingActivities', years) ?? calculateLTM(periodMap, 'financingCashFlow', years)) : null,
        unit: 'millions'
      },
      {
        label: "Net Change in Cash",
        isImportant: true,
        isBold: true,
        hasBorderTop: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.netChangeInCash ?? null])),
        ltm: type === 'quarter' ? calculateLTM(periodMap, 'netChangeInCash', years) : null,
        unit: 'millions'
      },
      {
        label: "Cash at Beginning of Period",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.cashAtBeginningOfPeriod ?? null])),
        ltm: type === 'quarter' ? calculateLTM(periodMap, 'cashAtBeginningOfPeriod', years) : null,
        unit: 'millions'
      },
      {
        label: "Cash at End of Period",
        isIndented: true,
        isBold: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.cashAtEndOfPeriod ?? null])),
        ltm: type === 'quarter' ? calculateLTM(periodMap, 'cashAtEndOfPeriod', years) : null,
        unit: 'millions'
      }
    ];
    
    return data;
  };

  const processBalanceSheets = () => {
    const type = selectedPeriod;
    // Build a map of normalized period -> statement
    const periodMap: Record<string, any> = {};
    balanceSheets.forEach(s => {
      const norm = normalizePeriod(s.period, type, s.calendarYear, s.date);
      if (norm) periodMap[norm] = s;
    });
    // For annual, use years; for quarter, use all year-Qx in periodsByYear
    const periods = type === 'annual'
      ? years
      : years.flatMap(year => ['Q1','Q2','Q3','Q4'].map(q => `${year}-${q}`));
    const data = [
      // ASSETS SECTION
      {
        label: "ASSETS",
        isImportant: true,
        isBold: true,
        hasBorderTop: true,
        isHeaderRow: true,
        ...Object.fromEntries(periods.map(p => [p, null])), // Header row
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Current Assets:",
        isImportant: true,
        ...Object.fromEntries(periods.map(p => [p, (() => {
          // Calculate current assets as sum of components
          const cash = periodMap[p]?.cashAndCashEquivalents || 0;
          const shortTermInv = periodMap[p]?.shortTermInvestments || 0;
          const receivables = periodMap[p]?.netReceivables || 0;
          const inventory = periodMap[p]?.inventory || 0;
          const otherCurrent = periodMap[p]?.otherCurrentAssets || 0;
          const total = cash + shortTermInv + receivables + inventory + otherCurrent;
          return total > 0 ? total : null;
        })()])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Cash & Equivalents",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.cashAndCashEquivalents ?? null])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Short Term Investments",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.shortTermInvestments ?? null])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Net Receivables",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.netReceivables ?? null])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Inventory",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.inventory ?? null])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Other Current Assets",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, (() => {
          const other = periodMap[p]?.otherCurrentAssets || 0;
          return other !== 0 ? other : null;
        })()])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Non-Current Assets:",
        isImportant: true,
        hasBorderTop: true,
        ...Object.fromEntries(periods.map(p => [p, (() => {
          // Calculate non-current assets as sum of components
          const ppe = periodMap[p]?.propertyPlantEquipmentNet || 0;
          const goodwill = periodMap[p]?.goodwill || 0;
          const intangible = periodMap[p]?.intangibleAssets || 0;
          const longTermInv = periodMap[p]?.longTermInvestments || 0;
          const otherNonCurrent = periodMap[p]?.otherNonCurrentAssets || 0;
          const total = ppe + goodwill + intangible + longTermInv + otherNonCurrent;
          return total > 0 ? total : null;
        })()])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "PP&E Net",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.propertyPlantEquipmentNet ?? null])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Goodwill",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.goodwill ?? null])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Intangible Assets",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.intangibleAssets ?? null])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Long Term Investments",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, (() => {
          const investments = periodMap[p]?.longTermInvestments || 0;
          return investments !== 0 ? investments : null;
        })()])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Other Non-Current Assets",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, (() => {
          const other = periodMap[p]?.otherNonCurrentAssets || 0;
          return other !== 0 ? other : null;
        })()])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Total Assets",
        isImportant: true,
        isBold: true,
        hasBorderTop: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.totalAssets ?? null])),
        ltm: null,
        unit: 'millions'
      },
      // LIABILITIES & EQUITY SECTION
      {
        label: "LIABILITIES & EQUITY",
        isImportant: true,
        isBold: true,
        hasBorderTop: true,
        isHeaderRow: true,
        ...Object.fromEntries(periods.map(p => [p, null])), // Header row
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Current Liabilities:",
        isImportant: true,
        ...Object.fromEntries(periods.map(p => [p, (() => {
          // Calculate current liabilities as sum of components
          const payables = periodMap[p]?.accountPayables || 0;
          const shortTermDebt = periodMap[p]?.shortTermDebt || 0;
          const deferredRev = periodMap[p]?.deferredRevenue || 0;
          const otherCurrent = periodMap[p]?.otherCurrentLiabilities || 0;
          const total = payables + shortTermDebt + deferredRev + otherCurrent;
          return total > 0 ? total : null;
        })()])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Accounts Payable",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.accountPayables ?? null])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Short Term Debt",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.shortTermDebt ?? null])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Deferred Revenue",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, (() => {
          const deferred = periodMap[p]?.deferredRevenue || 0;
          return deferred !== 0 ? deferred : null;
        })()])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Other Current Liabilities",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, (() => {
          const other = periodMap[p]?.otherCurrentLiabilities || 0;
          return other !== 0 ? other : null;
        })()])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Non-Current Liabilities:",
        isImportant: true,
        hasBorderTop: true,
        ...Object.fromEntries(periods.map(p => [p, (() => {
          // Calculate non-current liabilities as sum of components
          const longTermDebt = periodMap[p]?.longTermDebt || 0;
          const deferredRevNonCurrent = periodMap[p]?.deferredRevenueNonCurrent || 0;
          const otherNonCurrent = periodMap[p]?.otherNonCurrentLiabilities || 0;
          const total = longTermDebt + deferredRevNonCurrent + otherNonCurrent;
          return total > 0 ? total : null;
        })()])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Long Term Debt",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.longTermDebt ?? null])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Deferred Revenue (Non-Current)",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, (() => {
          const deferred = periodMap[p]?.deferredRevenueNonCurrent || 0;
          return deferred !== 0 ? deferred : null;
        })()])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Other Non-Current Liabilities",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, (() => {
          const other = periodMap[p]?.otherNonCurrentLiabilities || 0;
          return other !== 0 ? other : null;
        })()])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Total Liabilities",
        isImportant: true,
        isBold: true,
        hasBorderTop: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.totalLiabilities ?? null])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Shareholders' Equity:",
        isImportant: true,
        hasBorderTop: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.totalStockholdersEquity ?? null])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Common Stock",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.commonStock ?? null])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Retained Earnings",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.retainedEarnings ?? null])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Other Equity",
        isIndented: true,
        ...Object.fromEntries(periods.map(p => [p, (() => {
          const total = periodMap[p]?.totalStockholdersEquity || 0;
          const common = periodMap[p]?.commonStock || 0;
          const retained = periodMap[p]?.retainedEarnings || 0;
          const other = total - common - retained;
          return other !== 0 ? other : null;
        })()])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Total Equity",
        isImportant: true,
        isBold: true,
        hasBorderTop: true,
        ...Object.fromEntries(periods.map(p => [p, periodMap[p]?.totalStockholdersEquity ?? null])),
        ltm: null,
        unit: 'millions'
      },
      {
        label: "Total Liabilities & Equity",
        isImportant: true,
        isBold: true,
        hasBorderTop: true,
        ...Object.fromEntries(periods.map(p => [p, (() => {
          const liabilities = periodMap[p]?.totalLiabilities || 0;
          const equity = periodMap[p]?.totalStockholdersEquity || 0;
          return liabilities + equity > 0 ? liabilities + equity : null;
        })()])),
        ltm: null,
        unit: 'millions'
      }
    ];
    
    return data;
  };

  const exportToExcel = async () => {
    if (isExporting) return; // Prevent multiple exports
    
    setIsExporting(true);
    try {
      // Create workbook
      const wb = XLSX.utils.book_new();
      
      // Process and export each statement type
      const incomeData = processIncomeStatements();
      const cashFlowData = processCashFlowStatements();
      const balanceSheetData = processBalanceSheets();
      
      // Helper function to format data for Excel with proper structure
      const formatDataForExcel = (data: any[], title: string) => {
        // Create proper Excel structure with clear headers
        const excelData: any[] = [];
        
        // Add title and metadata
        excelData.push([`${title} - ${currentSymbol}`]);
        excelData.push([`Period: ${selectedPeriod.toUpperCase()}`]);
        excelData.push([`Export Date: ${new Date().toLocaleDateString()}`]);
        excelData.push([]); // Empty row
        
        // Create header row
        const headerRow = ['Financial Metric'];
        years.forEach(year => {
          if (selectedPeriod === 'quarter') {
            ['Q1', 'Q2', 'Q3', 'Q4'].forEach(q => {
              headerRow.push(`${year} ${q}`);
            });
          } else {
            headerRow.push(year);
          }
        });
        // Add LTM column for quarterly data
        if (selectedPeriod === 'quarter') {
          headerRow.push('LTM');
        }
        excelData.push(headerRow);
        
        // Add data rows
        data.forEach(row => {
          const dataRow = [row.label];
          years.forEach(year => {
            if (selectedPeriod === 'quarter') {
              ['Q1', 'Q2', 'Q3', 'Q4'].forEach(q => {
                const period = `${year}-${q}`;
                const value = row[period];
                dataRow.push(value !== null && value !== undefined 
                  ? typeof value === 'number' 
                    ? value.toLocaleString('en-US', { 
                        minimumFractionDigits: 0, 
                        maximumFractionDigits: 2 
                      })
                    : value
                  : '-');
              });
            } else {
              const value = row[year];
              dataRow.push(value !== null && value !== undefined 
                ? typeof value === 'number' 
                  ? value.toLocaleString('en-US', { 
                      minimumFractionDigits: 0, 
                      maximumFractionDigits: 2 
                    })
                  : value
                : '-');
            }
          });
          // Add LTM value for quarterly data
          if (selectedPeriod === 'quarter') {
            const ltmValue = row.ltm;
            dataRow.push(ltmValue !== null && ltmValue !== undefined 
              ? typeof ltmValue === 'number' 
                ? ltmValue.toLocaleString('en-US', { 
                    minimumFractionDigits: 0, 
                    maximumFractionDigits: 2 
                  })
                : ltmValue
              : '-');
          }
          excelData.push(dataRow);
        });
        
        return excelData;
      };
      
      // Convert data to Excel format with proper structure
      const incomeSheet = XLSX.utils.aoa_to_sheet(formatDataForExcel(incomeData, "Income Statement"));
      const cashFlowSheet = XLSX.utils.aoa_to_sheet(formatDataForExcel(cashFlowData, "Cash Flow Statement"));
      const balanceSheet = XLSX.utils.aoa_to_sheet(formatDataForExcel(balanceSheetData, "Balance Sheet"));
      
      // Set column widths for better readability
      const setColumnWidths = (sheet: XLSX.WorkSheet) => {
        const numDataColumns = years.length * (selectedPeriod === 'quarter' ? 4 : 1);
        sheet['!cols'] = [
          { width: 35 }, // First column (Financial Metric) - wider for longer names
          ...Array(numDataColumns).fill({ width: 18 }) // Data columns
        ];
      };
      
      // Apply formatting and styling
      const applySheetFormatting = (sheet: XLSX.WorkSheet, title: string) => {
        setColumnWidths(sheet);
        
        // Add some basic styling if needed
        // Note: XLSX library has limited styling support, but we can set column widths
        // For more advanced styling, you'd need a library like ExcelJS
      };
      
      applySheetFormatting(incomeSheet, "Income Statement");
      applySheetFormatting(cashFlowSheet, "Cash Flow Statement");
      applySheetFormatting(balanceSheet, "Balance Sheet");
      
      // Create summary sheet with proper structure
      const summaryData = [
        ['Financial Summary Report'],
        [],
        [`Company: ${currentSymbol}`],
        [`Period: ${selectedPeriod.toUpperCase()}`],
        [`Export Date: ${new Date().toLocaleDateString()}`],
        [`Export Time: ${new Date().toLocaleTimeString()}`],
        [],
        ['Available Data:'],
        [` Income Statement: ${incomeData.length} metrics`],
        [` Cash Flow Statement: ${cashFlowData.length} metrics`],
        [` Balance Sheet: ${balanceSheetData.length} metrics`],
        [` Time Periods: ${years.length} years`],
        [],
        ['Note: All values are in millions of USD unless otherwise specified'],
        [],
        ['Data Source: Financial Modeling Prep API'],
        ['Generated by: FinHubIQ Financial Dashboard']
      ];
      
      const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
      summarySheet['!cols'] = [{ width: 60 }];
      
      // Add sheets to workbook
      XLSX.utils.book_append_sheet(wb, summarySheet, "Summary");
      XLSX.utils.book_append_sheet(wb, incomeSheet, "Income Statement");
      XLSX.utils.book_append_sheet(wb, cashFlowSheet, "Cash Flow");
      XLSX.utils.book_append_sheet(wb, balanceSheet, "Balance Sheet");
      
      // Generate filename with timestamp
      const timestamp = new Date().toISOString().split('T')[0];
      const filename = `${currentSymbol}_Financial_Statements_${selectedPeriod}_${timestamp}.xlsx`;
      
      // Generate Excel file
      XLSX.writeFile(wb, filename);
      
      // Show success feedback
      toast({
        title: "Export Successful",
        description: `Financial statements exported to ${filename}`,
        variant: "default",
      });
      
    } catch (error) {
      console.error(' Error exporting to Excel:', error);
      toast({
        title: "Export Failed",
        description: "Error exporting to Excel. Please try again.",
        variant: "destructive",
      });
    } finally {
      setIsExporting(false);
    }
  };

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader className="pb-3 flex flex-row items-center justify-between space-y-0">
          <div>
            <CardTitle className="text-xl font-bold" style={{ color: 'var(--finhub-title)' }}>Historical Financials</CardTitle>
            <CardDescription>
              Financial statements for {currentSymbol}
            </CardDescription>
          </div>
          <div className="flex items-center gap-4">
            <Select value={selectedPeriod} onValueChange={(value: 'annual' | 'quarter') => setSelectedPeriod(value)}>
              <SelectTrigger className="w-32">
                <SelectValue placeholder="Select period" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="annual">Annual</SelectItem>
                <SelectItem value="quarter">Quarterly</SelectItem>
              </SelectContent>
            </Select>
            <Button 
              variant="outline" 
              size="sm" 
              onClick={exportToExcel}
              disabled={isExporting}
            >
              <Download className="h-4 w-4 mr-2" />
              {isExporting ? "Exporting..." : "Export to Excel"}
            </Button>
          </div>
        </CardHeader>
        <CardContent>
          {showSubscriptionWarning && (
            <Alert className="border-amber-200 bg-amber-50 mb-6">
              <AlertTriangle className="h-4 w-4 text-amber-600" />
              <AlertDescription className="text-amber-800">
                <strong>Quarterly data not available:</strong> Your current API subscription doesn&apos;t include quarterly financial data. 
                Showing annual data instead. To access quarterly data, please upgrade your Financial Modeling Prep subscription.
              </AlertDescription>
            </Alert>
          )}
          
          <Tabs value={activeFinancialTab} onValueChange={setActiveFinancialTab} className="space-y-4">
            <TabsList className="grid w-full grid-cols-3">
              <TabsTrigger 
                value="income-statement"
                className="data-[state=active]:border-primary data-[state=active]:bg-transparent data-[state=active]:shadow-none border-b-2 border-transparent rounded-none transition-all"
              >
                Income Statement
              </TabsTrigger>
              <TabsTrigger 
                value="cash-flow"
                className="data-[state=active]:border-primary data-[state=active]:bg-transparent data-[state=active]:shadow-none border-b-2 border-transparent rounded-none transition-all"
              >
                Cash Flow
              </TabsTrigger>
              <TabsTrigger 
                value="balance-sheet"
                className="data-[state=active]:border-primary data-[state=active]:bg-transparent data-[state=active]:shadow-none border-b-2 border-transparent rounded-none transition-all"
              >
                Balance Sheet
              </TabsTrigger>
            </TabsList>
            
            <TabsContent value="income-statement" className="mt-6">
              {incomeLoading ? (
                <TableLoadingSkeleton rows={12} />
              ) : (
                renderFinancialTable(processIncomeStatements(), "Income Statement", incomePeriodMap)
              )}
            </TabsContent>
            
            <TabsContent value="cash-flow" className="mt-6">
              {cashFlowLoading ? (
                <TableLoadingSkeleton rows={8} />
              ) : (
                renderFinancialTable(processCashFlowStatements(), "Cash Flow Statement", cashFlowPeriodMap)
              )}
            </TabsContent>
            
            <TabsContent value="balance-sheet" className="mt-6">
              {balanceSheetLoading ? (
                <TableLoadingSkeleton rows={10} />
              ) : (
                renderFinancialTable(processBalanceSheets(), "Balance Sheet", balancePeriodMap)
              )}
            </TabsContent>
          </Tabs>
        </CardContent>
      </Card>
    </div>
  );
}